
last-mile vs interchange
-------------------------------

An interchange format is characterized by an expectation that asset structure, and artist choice points, including overrides and variations, are preserved wherever the asset is imported, and that the straight import/export of the data is round trip loss-less.

What last mile means is that the formats have imposed an opinion on the contents of the input data and conformed it to that opinion. All the richness and complexity of the asset, including artist choice points, have been flattened away at best, and completely deleted at worst. Characteristically however, a last mile format is ideal for a particular process or step in a production pipeline. 

I will say up front that there are no pure interchange formats, although there are many pure last-mile formats. 

gltf and fbx (100 % last-mile)
----------------

gltf and fbx are last-mile formats, not interchange formats.

gltf has elided structure and choice points in order to prepare OpenGL ready buffer data ideal for the most common class of shader programs which render a model, possibly with a Disney-esque PBR shading model.

fbx seems like it might be an interchange format, but in fact, it is a last mile format. It takes complex asset structure and choice points, and reduces it to the strict subset of functionality supported by Motion Builder. It only feels like an interchange format because of the deceptive complexity of the format. Nonetheless, the correct use of an fbx file is Maya -> fbx -> { Motion Builder, Unreal, etc. } A typical backwards workflow, Motion Builder -> fbx -> Maya will typically be used to bring animation data back to Maya, but not for example geometry edits.

alembic (60% last mile)
-----------

Alembic is also on the last mile side of the balance. Although it can 
interchange geometry data and scene structure, in general, it is commonly 
used as a cached format holding the outputs of a simulation. In that sense 
Alembic holds an opinionated rendering of a simulation sampled over time. 
It is much more general than gltf and fbx in that it is schema based and 
can be easily extended. Layering is currently being introduced to move 
alembic more to the interchange side of the scale, but it's not clear to 
me how to move forward on missing core semantics necessary for 
characters; Alembic currently lacks skeletal bindings, an early design choice.

usd (20% last mile)
-----

USD is last mile as well, but it's last mile is complex enough that it can be 
coerced into general interchange. What I mean by that, is that USD encodes a 
full Scenegraph with the same complexity and expressiveness of the Maya hypergraph,
or ILM's Zeno Sg scenegraph, including the equivalent of what Zeno terms shotfiles, 
but in a more generalized form. Where USD diverges from the Hypergraph and Sg is 
that USD does not encode the dataflow graph of Maya, or the operator graph of
Zeno. That is what biases USD to interchange rather than last mile, as a strict 
encoding of an operator graph would be a fully implemented and opinionated end 
point and would require that users of USD conform to that computational model.

Currently Pixar is working with partners to extend the core schemas to add missing 
character features. The proposal on the table is a superset of FBX's support. 
The proposal supports 

- animation clips
- shareable skeletons
- skin/joint weighting
- blend shapes (including linear in-betweens)


Application support
--------------------------

gltf - Blender, online fbx converter

fbx - just about everything. A caution is that development has been frozen with
maintenance developers only working on it.

alembic - all high end DCC's, blender coming online slowly
all Apple apps, including Preview and Quicklook

usd - Pixar supplies plugins for Maya, Houdini, Katana, Sketchup. Modo plug close to release.
all Apple apps, including Preview and Quicklook

Engine support
-------------------

gltf - web viewers

fbx - Unity, Unreal, most hobby engines

alembic - Unity, Unreal plugins exist, CryEngine

usd - Unreal support is in development. Unity support on github as plugin.

Conclusion
--------------

I'm banking on USD being critical for this kind of application, starting 
when character support lands. Building USD is also a challenge, but this 
situation is nearing resolution.


<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
