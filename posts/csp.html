<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>csp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="../js/tracking.js"></script>
  <style>
/* 
 This document has been created with Marked.app <http://markedapp.com>, Copyright 2011 Brett Terpstra
 Please leave this notice in place, along with any additional credits below.
 ---------------------------------------------------------------
 Title: Antique
 Author: Brett Terpstra
 Description: An "antiqued" theme with off-white background and serif typography
 */
body{font:normal .8764em/1.5em Georgia,"Times New Roman",serif;margin:0}html>body{font-size:14px}p{margin:1.3125em 0;font-size:1.1429em;line-height:1.3125em}ul{list-style:square}ul ul{list-style:circle}li{font-size:110%}li li{font-size:100%}li p{font-size:100%}h1{margin:.6563em 0;font-size:2.2857em;line-height:1.6563em}h2{margin:.875em 0;font-size:1.7143em;line-height:.875em}h3{margin:1em 0;font-size:1.5em;line-height:1em}h4{margin:1.1667em 0;font-size:1.2857em;line-height:1.1667em}h5{margin:1.3125em 0;font-size:1.1429em;line-height:1.3125em}h6{margin:1.5em 0;font-size:1em;line-height:1.5em}h1,h2,h3{font-weight:normal;border-bottom:solid 1px #ccc;padding-bottom:.4em;padding-top:1em;border-color:#b8b4a4;color:#514d3f;font-family:"Hoefler Text";line-height:1.5em}body,p,td,div{color:#45462f;word-wrap:break-word;-webkit-font-smoothing:antialiased}a{color:hsl(185,33%,33%);text-decoration:none;-webkit-transition:color .2s ease-in-out}a:hover{color:#7aa45c}strong{font-weight:600;color:#605b4b}.footnote{font-size:.8em;vertical-align:super;color:#0d6ea1}#wrapper img{max-width:100%;height:auto}dt{font-weight:bold}dd{margin-bottom:1em}@media print{body{overflow:auto;background:#fff;color:#000!important}img,pre,blockquote,table,figure{page-break-inside:avoid}#wrapper{background:#fff;position:relative;color:#000;text-indent:0;padding:1in;font-size:85%}}@media screen{::selection{background:rgba(157,193,200,.5)}h1::selection{background-color:rgba(45,156,208,.3)}h2::selection{background-color:rgba(90,182,224,.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,.3)}code::selection{background-color:rgba(0,0,0,.7);color:#eee}code span::selection{background-color:rgba(0,0,0,.7)!important;color:#eee!important}a::selection{background-color:rgba(255,230,102,.2)}.inverted a::selection{background-color:rgba(255,230,102,.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,.5)}.inverted{background:#0b2531}body{height:100%;background:rgba(240,237,227,1)}.inverted{background:rgba(57,54,47,1)}.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted pre,.inverted code,.inverted th,.inverted hr,.inverted strong,.inverted em,.inverted .math,.inverted dd,.inverted dt{color:rgba(240,237,227,1)!important;border-color:rgba(66,61,47,1);background:rgba(57,54,47,1)!important}.inverted hr{border-color:rgba(52,52,52,.3)}.inverted a{color:#fff;text-decoration:underline;border-bottom:0}#wrapper{color:#514d3f;overflow:auto;text-indent:0;padding:25px}}li>p:first-child{margin:0}li p{margin:.5em 0}ul ul,ul ol{margin-bottom:.4em}caption,col,colgroup,table,tbody,td,tfoot,th,thead,tr{border-spacing:0}table{display:table;table-layout:fixed;border-collapse:collapse;empty-cells:hide;margin:0;padding:0;margin-bottom:24px;border:0}caption{display:table-caption;font-weight:bold}col{display:table-column}colgroup{display:table-column-group}tbody{display:table-row-group}tfoot{display:table-footer-group}thead{display:table-header-group}td,th{display:table-cell}th{font-weight:bold}tr{display:table-row}table{margin-top:-1px;margin-bottom:23px;border:1px solid rgba(0,0,0,0.25)}table th,table td{padding:0 1em;font-size:1.1em;line-height:23px}table thead{background-color:rgba(0,0,0,0.15)}table tbody{background-color:rgba(0,0,0,0.05)}table tfoot{background-color:rgba(0,0,0,0.15)}table tr:nth-child(odd){background-color:rgba(255,255,255,0.06)}table tr:nth-child(even){background-color:rgba(0,0,0,0.06)}table th:nth-child(odd),table td:nth-child(odd){background-color:rgba(255,255,255,0.06)}table td:nth-child(even){background-color:rgba(0,0,0,0.06)}table thead{border:1px solid rgba(0,0,0,0.15);border-bottom:1px solid rgba(0,0,0,0.2)}table tfoot{border:1px solid rgba(0,0,0,0.15);border-top:1px solid rgba(0,0,0,0.2)}figure{position:relative;display:inline-block;margin-bottom:2em}figcaption{text-align:center;position:absolute;background:rgba(0,0,0,.5);width:100%;left:0;bottom:-20px;color:rgba(255,255,255,.7);-webkit-transition:all .2s ease-in-out}figure:hover{cursor:pointer}figcaption:hover{background:rgba(0,0,0,.56);color:rgba(255,255,255,1)}.poetry pre{font-family:Georgia,Garamond,serif!important;font-style:italic;font-size:110%!important;line-height:1.6em;display:block;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif!important}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;vertical-align:super;position:relative}sub{vertical-align:sub;top:-1px}
</style>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38190740-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


</head>
<body class="normal">
  <div id="wrapper">
      <h1 id="communicatingsequentialprocesses">Communicating Sequential Processes</h1>

<p>The book <em>Communicating Sequential Processes</em> introduces a formal calculus of processes;
its formalisms and structures are reflected in the design of modern concurrent languages
and libraries such as occam, libthread, Go, CHP, and more.</p>

<p>This article is a brief overview of the book Communicating Sequential Processes, by
C.A.R. Hoare, June 21, 2004, first published in 1985 by Prentice Hall International,
and obtained online at: <a href="http://www.usingcsp.com/">http://www.usingcsp.com/</a></p>

<p>I took a lot of notes while reading the book, and thought that the notes might help
others tackle the subject matter. I&#8217;d appreciate any corrections or suggestions on how
to make this article more useful.</p>

<p>Hoare&#8217;s student <a href="http://web.comlab.ox.ac.uk/people/Bill.Roscoe/">Bill Roscoe</a> developed
the ideas further, and published a new book in 1997 (revised through 2005) called
<em>The Theory and Practice of Concurrency.</em> In this revised version of my CSP article,
I factor in my notes on reading Roscoe. Roscoe&#8217;s book is available online at
<a href="http://web.comlab.ox.ac.uk/oucl/work/bill.roscoe/publications/68b.pdf">this location</a>. </p>

<h1 id="introduction">Introduction</h1>

<p>CSP is a system for describing the behavior of concurrent systems, which are systems that
perform a number of activities at the same time. The systems need to coordinate their
activities in some way, and communicate between themselves. The systems might be as
loosely coupled as workstations on a network, or as integrated as a number of components
on a single VLSI chip. The intent of the theory of CSP is threefold: </p>

<ul>
<li>To describe interesting applications</li>
<li>Be efficiently implementable</li>
<li>Assist the programmer in specification, design, verification, and validation of systems</li>
</ul>

<p>CSP is a calculus of interaction.</p>

<h1 id="processes">Processes</h1>

<p>A process is the behavior pattern of an object. Behavior is described as a pattern wherein
events lead to other behaviors. Events are instantaneous actions - atomic actions
without duration.
There&#8217;s nothing special about an event, there imply no causality. Events are not considered
to be sent or received, rather, they merely represent that something has occurred, and
therefore a further pattern of action is expected. Another way to describe an event is
as a synchronization primitive that one or more processes can engage with.</p>

<p>We might denote some sample processes:</p>

<pre><code>(guestsArrived -&gt; LETS_EAT) (keyTurned -&gt; ENGINE_STARTS)
</code></pre>

<p>Generally, we might write:</p>

<pre><code>(x -&gt; P)
</code></pre>

<p>which we read as &#8220;x then P&#8221;. The process described engages in event &#8220;x&#8221;, then behaves as
described by &#8220;P&#8221;. The arrow operator always takes an event on the left and a process
on the right. The arrow operator is right associative, which means that we could write: </p>

<pre><code>(x -&gt; (y -&gt; P)) = (x -&gt; y -&gt; P)
</code></pre>

<p>CSP defines two special primitive processes, STOP and SKIP. SKIP is a process that is
always ready to go, and immediately terminates successfully. STOP is a process that is
never ready, does nothing, and never terminates. It is mostly used as dummy item.</p>

<p>Since actions are instantaneous, we need to represent extended actions as a pair of events
indicating the start and the end. In CSP, timing is ignored since timing can be treated
independently of logical correctness. Simultaneity is not a concept; if it is important
that two events occur simultaneously, they are treated as a single event.</p>

<p>A machine that accepts two coins, dispenses two chocolates, and stops can be described as:</p>

<pre><code>(coin -&gt; (choc -&gt; (coin -&gt; (choc -&gt; STOP))))
</code></pre>

<p>If this sequence was to repeat indefinitely, recursion could be used. A clock might be
described by ticks:</p>

<pre><code>(tick -&gt; CLOCK)
</code></pre>

<p>A CLOCK can emit a single tick, and we can define </p>

<pre><code>CLOCK = (tick -&gt; CLOCK)
</code></pre>

<p>This can then be expanded via substitution as many times as we want. </p>

<pre><code>CLOCK = (tick -&gt; tick -&gt; tick -&gt; tick -&gt;(tick -&gt; CLOCK))
</code></pre>

<p>If the chocolate vending machine described earlier has an unlimited supply of chocolate,
it could be defined as </p>

<pre><code>VM = (coin -&gt; (choc -&gt; VM))
</code></pre>

<p>These recursions have a prefix, which is to say: they start with a one or more events.
Such an equation is called guarded, and all guarded equations have a solution.</p>

<p>We can prove that all guarded equations have a solution: every guarded equation can have a
process substituted that just makes the chain longer but still satisfies the original
equation.</p>

<p>This lets us say that two processes that behave the same are the same process, which
comes in handy for proofs and simplifications.</p>

<p>Recursion can be mutual:</p>

<pre><code>CLOCKA = (ticka -&gt; CLOCKB) CLOCKB = (tickb -&gt; CLOCKA)
</code></pre>

<p>Choices are indicated with a bar. This equation </p>

<pre><code> (x -&gt; P | y -&gt; Q | z -&gt; R)
</code></pre>

<p>says that if x occurs behavior P results; if event y occurs behavior Q happens; and if
z occurs, R results. No other event is engaged with this process.</p>

<p>This idea can be used to implement a copy process. </p>

<pre><code>COPYBIT = (in.0 -&gt; out.0 -&gt; X | in.1 -&gt; out.1 -&gt; X)
</code></pre>

<p>The only distinction between the notions of input and output in a process is that the
environment can provide an input of in.0, or in.1, but the corresponding output has no
choices.</p>

<h2 id="traces">Traces</h2>

<p>Traces are a record of events. The trace of the coin for chocolate machine described
earlier would be </p>

<pre><code>&lt;coin, choc, coin, choc, STOP&gt;
</code></pre>

<p>Various algebraic laws are introduced, ultimately for the purpose of proving whether two
traces are equivalent. Two processes that generate the same trace are identical, so the
utility of proving traces are identical is that it might be easier to algebraically reduce
traces to each other than it might be to reduce the corresponding processes in order to
prove equivalence.</p>

<p>Specifications are defined (for example, x never exceeds 10); and satisfactions go with
them - one asserts that for every possible observation of a process, the specification
will be true. An algebra for conjunction of specifications is developed. The notions of
traces and specifications are important for proving that a system works properly.</p>

<h1 id="concurrency">Concurrency</h1>

<pre><code>P || Q 
</code></pre>

<p>indicates two processes that share an alphabet and proceed in lock-step synchronization;
in other words, in parallel, not concurrently. Should one process expect an event that
does not come from the other, a deadlock occurs. Deadlock means that each process is
prepared to engage in further action; but the the further actions are different, and
nothing further can happen.</p>

<p>An algebra on the || operator is defined, and the dining philosophers problem explored,
including the deadlock situation where all philosophers sit simultaneously. Various
solutions to the problem are derived.</p>

<p>Algebraic tools on concurrency are developed, allowing for various transformations on
processes. The utility of the algebra is that processes can be broken down, and composed
such that details of processes can be hidden so that processes can operate in a common
environment but not interact with each other. Actions can be further labeled so that the
action engages only a single process. </p>

<h1 id="nondeterminism">Nondeterminism</h1>

<p>Nondeterminism is introduced to describe situations where multiple actions are possible,
but the choice cannot be anticipated; it is made at the time the action occurs. For
example, a process cannot know which lever a user might pull, until the moment the lever
is pulled:</p>

<pre><code>(leftLever -&gt; A) [] (rightLever-&gt; B)
</code></pre>

<p>Rules are developed to determine what should happen if two events are available
simultaneously, or if an event can satisfy two processes simultaneously.</p>

<p>Refusals are defined as the set of actions that result in deadlock in a first step. The
existence of a known refusal can be used to implement an alternate choice that does not
result in a deadlock for the requested action.</p>

<p>Concealment is introduced to hide members of the alphabet whose occurrence requires
simultaneous participation with the environment. In other words, if an action is strictly
an internal transition, there is no need to expose that action to the alphabet the
environment can use on a process. Unfortunately, the introduction of concealment means
that guarded recursions are not constructive, and therefore liable to have more than one
solution. Divergence describes the case where non-determinism is required to describe a
process since no solution is otherwise possible.</p>

<p>Interleaving is similar to the || operator. If two processes with the same alphabet
are interleaved -</p>

<pre><code>P ||| Q
</code></pre>

<p>then one or the other of the processes can engage an action. If P cannot accept an action,
then Q can take it, and vice versa. If both can accept it, then one or the other will take
it, nondeterministically. If neither can take it, deadlock results. An algebra is
developed, as well as the behavior of traces and refusals, and the use of specifications.</p>

<h1 id="communications">Communications</h1>

<p>A communication is a special class of event described as a pair, c.v where c is the name
of a channel where the communication takes place, and v is the value of the passed message.
There are functions that can pick these apart:</p>

<pre><code>channel(c.v) = c, message(c.v) = v
</code></pre>

<p>Channels are defined to be unidirectional, and between two processes. A channel is a
potential set of events; one event for each value that might be communicated down the
channel. Channels are named into the alphabet of actions, for example, a copy process
might be written as</p>

<pre><code>COPY(left, right) = (left?x -&gt; right!x -&gt; X)
</code></pre>

<p>The question mark denotes input, the exclamation mark, output, so the equation says any
value x communicable on left arriving on the left channel results in the value x being
emitted from the right channel, followed by process X.</p>

<p>More complex expressions are introduced using if/then/else statements to perform
transformations on an input stream. The choice operator can be used to invoke different
processes when different actions arrive, as developed in previous chapters. The concurrency
operator || is extended when P || Q communicate via channel. In that case, the definition
of concurrent actions is extended to say that actions can occur when P outputs a value on
c that is expected as an input on Q, and vice versa. Communication can thus be regarded
as a special case of the prefix operator. Internal communications can be concealed.
Similarly to previous chapters, proving the absence of deadlock between communicating
processes can be proven.</p>

<p>Since two processes are connected by a single channel, any network of non-stopping
processes free of cycles cannot deadlock, since any acyclic graph can be decomposed
into subgraphs connected only by a single arrow.</p>

<p>Various examples show how data flow networks can be set up to compute streams of results
from streams of input data. In general, if processes describe an operation, any
mathematical expression can be described as processes communicating via channels. When
the networks are large but regular, a subscripted notation can describe an iterative
array. If the connection diagram has no directed cycles, the array is known as a
systolic array.</p>

<h2 id="pipes">Pipes</h2>

<p>Processes that have only two channels in their alphabet, namely an input and an output,
are called pipes.</p>

<pre><code>P &gt;&gt; Q
</code></pre>

<p>which is read as &#8220;P pipes to Q&#8221;.</p>

<p>Concatenated pipes can become a single pipe through concealment. Pipes are associative
if the connected channels are capable of transmitting the same kind of message. The
process within a pipe may transform the stream.</p>

<p>The chaining operator connects two processes by just one channel,
and so can&#8217;t deadlock. It can however introduce a new danger of livelock, which results
when P and Q spend all their time communicating with each other and never the external
world. To prove that livelock is not a danger, P must be left-guarded in the sense that
the sequence of outputs of P must be bounded by some function of the sequence of inputs.
Q must be right-guarded in the sense that it must output no more symbols than are input.</p>

<h2 id="buffers">Buffers</h2>

<p>Buffers are special processes that output exactly their input, possibly after some delay.
When non-empty, a buffer is always ready to output. A buffer is free of livelock.</p>

<p>Protocols describe two processes, a transmitter and a receiver, connected in series as a
buffer.</p>

<pre><code>(T &gt;&gt; R)
</code></pre>

<p>In practice T and R might be connected by a process WIRE, which might not behave exactly
as a buffer, due to unreliability. A protocol is a layered process that allows a
nondeterministic process to behave as a buffer, by layering communication, usually
involving a second backflowing channel used for handshaking. Various laws are
described to prove the correctness of a protocol.</p>

<h1 id="sequentialprocesses">Sequential processes</h1>

<p>A process P might be broken broken down into two processes that must execute in sequence.
This is denoted
 P = Q ; R</p>

<p>A repeating process or loop can be defined recursively:</p>

<pre><code>P = (P ; X) = P ; P ; P ; P ; ...
</code></pre>

<p>A sequence of symbols is said to be a sentence of process P if P terminates successfully
after engaging in the corresponding sequence of actions. The set of all such sentences
is called the language accepted by P. The notation of describing sequential processes may
thus be used to define the grammar of a language. This treatment is familiar to anyone who
has studied parsers.</p>

<p>Algebraic treatment of deterministic and non-deterministic processes is presented.</p>

<h2 id="interrupts">Interrupts</h2>

<p>Interrupts are defined as a sequential composition </p>

<pre><code>(P ^ Q) 
</code></pre>

<p>where the progress of P is interrupted on occurrence of the first event of Q, and P is
never resumed. A catastrophe is an interrupt that occurs for some unspecified reason;
the catastrophe symbol can be used to specify a recovery process Q. A restart facility is
one such recovery process. Checkpoints can indicate restarts of lesser severity than
restarting the whole system.</p>

<p>Assignments, conditionals, and loops are defined to encompass the most important aspects
of conventional sequential programming. There are no surprises here.</p>

<h1 id="sharedresources">Shared resources</h1>

<p>Since channels cannot explicitly be shared, methods, such as labeling or interleaving
must be contrived to create enough separate channels for independent communication in a
way that the equations are satisfied.</p>

<p>The problem of interference is introduced, wherein two processes attempt to modify a
shared variable, but since both read the initial value before either completes its write,
a transaction is lost. A critical region is proposed as a possible solution to the
problem. A mutex is also suggested. Finally, it is noted that atomic operations are best,
since no ambiguity of sequence can result. It is reasonably proposed that each shared
resource in a system be specifically designed for its purpose, and that pure storage not
be explicitly shared in a concurrent system design.</p>

<h1 id="discussion">Discussion</h1>

<p>The central premise driving CSP is that a single job should be able to take advantage of
the parallelism provided by a computer&#8217;s hardware.</p>

<p>Shared storage is a typical hardware solution to this, but has the problem previously
introduced of interference.</p>

<p>Fork and join, wherein the locus of program control can be split such that two processors
execute the same program independently, and then rejoined when a specific label is waited
upon by both processors simultaneously, is deemed unnecessarily complicated to use, and
therefore problem prone.</p>

<p>Dijkstra proposed that forked processes should execute to completion and that the join
should be implicit when all forked processes have completed. These processes would have
no shared interaction, save through channels. This notion forms the basis of the
concurrent processes in CSP.</p>

<p>Dijkstra further proposed critical regions should protect shared storage so that
concurrent processes could share variables. Variables declared as shared give a compiler
a hint that a critical region can surround operations on that variable automatically.
Such a pattern might look like this:</p>

<pre><code>shared n : integer with n do n := n + 1;
</code></pre>

<p>Synchronization between processes could be further elaborated:</p>

<pre><code>with n when condition do critical region
</code></pre>

<p>Condition is tested on entry, and the critical region executed immediately if possible,
or deferred until condition is satisfied. There is a potential performance problem if
many processes need to enter the critical region, although this is a semantically
elegant solution.</p>

<p>Monitors are described. In modern parlance, a monitor is a class with private member
variables; all meaningful operations on data occur within method calls, these method
calls internally are made to operate sequentially by protecting the execution of each
method with a semaphore.</p>

<p>Specific embodiments of concurrency in Pascal Plus, Ada, a language named CSP, and Occam
are described. Certain advantages and limitations are mentioned.</p>

<p>We are reminded that a pipe is a unidirectional channel between two processes. Multiple
buffered channels are a natural generalization to allow any process to communicate with
any other in either direction. Unfortunately multiple buffered channels can allow deadlock.
It is noted that the ARPAnet is such a system, and that mathematical treatment is
complicated.</p>

<p>The book ends by noting that the case for the practical application of CSP is overstated,
but nonetheless, it has presented a sound mathematical basis for reasoning about
specifications, designs, and implementations.</p>

<p>The mathematical treatment convinced me of the practicality of the approach and its
correctness. I did feel that without automated tools, calculating the correctness of a
process in anything but the most trivial processes would be cumbersome.</p>

<p>This article has been a brief overview of a complex subject, mostly I am hoping to provide
a bit of a glimpse as to what the book covers in order to pique your interest. I
encourage you to read the book and work through the proofs to get a stronger
understanding of the theoretical foundations. As multicore, concurrent, and parallel
processes become more and more prevalent, the concepts in CSP are going to become
increasingly relevant today.</p>

<h1 id="footnote">Footnote</h1>

<p>If you wish to experiment with some of the concepts in CSP,
a useful implementation written in Haskell can be found here
<a href="http://chplib.wordpress.com/2009/11/16/an-introduction-to-communicating-sequential-processes">http://chplib.wordpress.com/2009/11/16/an-introduction-to-communicating-sequential-processes</a></p>
    </div>
</body>
</html>