<!DOCTYPE html>
<html id="home" lang="en">
<head>
<meta charset=UTF-8" />
<!-- disable iPhone inital scale --> 
<meta name="viewport" content="width=device-width; initial-scale=1.0" /> <link rel="shortcut icon" href="favicon.ico">  
<!--[if lt IE 9]> 
 <!-- html5.js for IE less than 9 --> 
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
 <!-- css3-mediaqueries.js for IE less than 9 --> 
	<script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
<![endif]--> 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38190740-1']); _gaq.push(['_trackPageview']);
 (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();
</script>
<link rel="stylesheet" href="../css/reset.css" type="text/css" />
<link rel="stylesheet" href="../css/isotype-style.css" type="text/css" media="screen" /> 
<link rel="stylesheet" href="../css/standard.css" type="text/css" />
<link rel="stylesheet" href="../css/buttons.css" type="text/css" /> 
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Aclonica:regular" type="text/css" /> 
<TITLE>
Smallest possible useful C++ Attribute system?
</TITLE></HEAD>
<BODY>
<div id="pagewrap">
<header id="header">
 <hgroup><h1 id="site-logo">Spaces Between</h1></hgroup>
</header>
<DIV id="articleHeader">
<H3 class='entry-date'>2008-06-08 17:28:38</h3>
<H1 class="title">Smallest possible useful C++ Attribute system?</H1>
</DIV>
<div id="content">
<article class="post">
<p></p> <p>Over the years, I've seen almost as many attribute reflection systems as I've worked on games, and that's a lot of games. This <a href="http://www.gamasutra.com/view/feature/3683/a_templated_c_attribute_library_.php">article</a> by Gary McNickle on Gamasutra is clean and easy to read, but it is not as small as possible. It inspired me to write a few notes about how I think these things should be put together.</p> <p>Here are the usage goals for the system:</p> <ul> <li>The game code owns the variables, not the attribute system <li>The attribute system does not force the game to use it <li>Attributes can be searched, and iterated over </li></ul> <p>Out of scope:</p> <ul> <li>Serialization to disk, and relocation <li>Implementation of features normally part of C++ or the STL</li></ul> <p>Here are some technical requirements I decided to hit:</p> <ul> <li>Only one copy of any name of any variable would ever be stored <li>As much as possible the system will self-priming <li>The system will be typesafe <li>Methods on the class may be templated for convenient type coercion <li>Avoid "best practices" such as accessors if they don't make the code simpler</li></ul> <p>I tried several variations, and each one got shorter and less complex. I started with a template meta-programmed solution, not unlike the cleverness referenced by Gary in the <a href="http://spirit.sourceforge.net/dl_more/fusion_v2/libs/fusion/doc/html/index.html">Boost spirit library</a>. The next version stripped this down to a much simpler templated attribute system; I simplified that through two rewrites. At first I pursued a template based system because the code tends to be easier to read than piles of preprocessor mess. I have a bit of a distaste for macro based systems because they tend to become unwieldy and difficult to maintain as features get wedged into the system, whereas template code remains legible. After some thought it occurred to me that if one kept the attribute system trivially simple, the macros could remain trivially simple. Templates could be used at a higher level than the base objects to implement the complexity. At this point, I overcame my built-in distaste for macro-based attribute systems, and came up with the smallest useful system I could think of. </p> <p>In real life, I would not use std::string, but rather a block of data containing the char data, and indexed by offsets. Blocks of data indexed by offsets are easy to relocate to keep memory compact, and are trivial to cache of to disk. This approach also avoids the constant overhead of a string object (which tends to be 32 bytes), and also avoids any small allocations from the heap (a string takes two).</p> <p>Also, I would think carefully about the use of std::map, to make sure it does not impact run time performance. A sure sign that an STL map of std::string is a poor choice is if profiling shows a measurable amount of time being spent in string comparisons.</p> <p>I wonder if this can be made smaller?</p> <p>&nbsp;</p><pre class="code"><span style="color: rgb(0,0,255)">#include</span> <span style="color: rgb(163,21,21)">&lt;typeinfo.h&gt; </span><span style="color: rgb(0,0,255)">#include</span> <span style="color: rgb(163,21,21)">&lt;string&gt; </span><span style="color: rgb(0,0,255)">#include</span> <span style="color: rgb(163,21,21)">&lt;map&gt; </span></pre><pre class="code"><span style="color: rgb(0,0,255)">class</span> AttributeBinder { <span style="color: rgb(0,0,255)">public</span>: <span style="color: rgb(0,0,255)">class</span> AttributeDescriptor { <span style="color: rgb(0,0,255)">public</span>: AttributeDescriptor() : ti(0), off(0) { } AttributeDescriptor(<span style="color: rgb(0,0,255)">const</span> <span style="color: rgb(0,0,255)">char</span>* name, <span style="color: rgb(0,0,255)">const</span> std::type_info&amp; ti, ptrdiff_t off) : name(name), ti(&amp;ti), off(off) { } AttributeDescriptor(<span style="color: rgb(0,0,255)">const</span> AttributeDescriptor&amp; rhs) : name(rhs.name), ti(rhs.ti), off(rhs.off) { } std::string name; ptrdiff_t off; <span style="color: rgb(0,0,255)">bool</span> typeEqual(<span style="color: rgb(0,0,255)">const</span> AttributeDescriptor&amp; rhs) { <span style="color: rgb(0,0,255)">return</span> *ti == *rhs.ti; } <span style="color: rgb(0,0,255)">private</span>: <span style="color: rgb(0,128,0)">// note, must compare type infos by *m_pInfo == *rhs.m_pInfo </span> <span style="color: rgb(0,128,0)">// because the pointers might not be the same, even if the types are </span> <span style="color: rgb(0,0,255)">const</span> std::type_info* ti; }; <span style="color: rgb(0,0,255)">void</span> bind(<span style="color: rgb(0,0,255)">const</span> <span style="color: rgb(0,0,255)">char</span>* varname, <span style="color: rgb(0,0,255)">const</span> std::type_info&amp; ti, ptrdiff_t offset) { attribs[varname] = AttributeDescriptor(varname, ti, offset); } std::map&lt;std::string, AttributeDescriptor&gt; attribs; }; </pre><a href="http://11011.net/software/vspaste"></a><pre class="code"><font color="#0000ff"></font> <span style="color: rgb(0,128,0)">// Within a class, create a binding object, and start the Bind method. // Note that it is valid to put other code between BIND_START and BIND_END // if you want it to run during the static Bind initialization. // Semicolons are optional after BIND_START, you can use them if you use // a pretty-printer on code and want things to line up nicely </span><span style="color: rgb(0,0,255)">#define</span> BIND_START \ <span style="color: rgb(0,0,255)">static</span> AttributeBinder binding; \ <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">void</span> Bind() \ { \ <span style="color: rgb(0,128,0)">// Bind a single variable </span><span style="color: rgb(0,0,255)">#define</span> BIND(c, v, t) \ binding.bind( #v, <span style="color: rgb(0,0,255)">typeid</span>(t), (ptrdiff_t)&amp;((c*)0)-&gt;v) <span style="color: rgb(0,128,0)">// End the bind method // Semicolons are optional after BIND_END, you can use them if you use // a pretty-printer on code and want things to line up nicely </span><span style="color: rgb(0,0,255)">#define</span> BIND_END \ } <span style="color: rgb(0,128,0)">// Instantiate the binding object for class C, and make a globally // instantiated struct whose constructor will invoke C's Bind method // which has been declared in BIND_START // This goes in the implementation file, in the same namespace as the // class C. </span><span style="color: rgb(0,0,255)">#define</span> BIND_ATTRIBUTES(c) \ AttributeBinder c::binding; \ <span style="color: rgb(0,0,255)">namespace</span> { \ <span style="color: rgb(0,0,255)">struct</span> Static ## c ## Binder \ { \ Static ## c ## Binder() { c::Bind(); } \ }; \ <span style="color: rgb(0,0,255)">static</span> Static ## c ## Binder <span style="color: rgb(0,0,255)">static</span> ## c ## binder; \ } </pre><a href="http://11011.net/software/vspaste"></a> <p>And here's an example of decorating a class:</p> <p>&nbsp;</p><pre class="code"><span style="color: rgb(0,0,255)">class</span> Foo { <span style="color: rgb(0,0,255)">public</span>: BIND_START; BIND(Foo, myInt, <span style="color: rgb(0,0,255)">int</span>); BIND(Foo, myFloat, <span style="color: rgb(0,0,255)">float</span>); BIND(Foo, bar, <span style="color: rgb(0,0,255)">float</span>); BIND_END; Foo() : myInt(1), myFloat(2), bar(3) { } <span style="color: rgb(0,0,255)">int</span> myInt; <span style="color: rgb(0,0,255)">float</span> myFloat; <span style="color: rgb(0,0,255)">float</span> bar; }; BIND_ATTRIBUTES(Foo);</pre><a href="http://11011.net/software/vspaste"></a> <p>&nbsp;</p> <p>Finally, to look up a variable, you would use your privileged knowledge of the implementation to do something like the following:</p><pre class="code"> Foo myFoo;</pre><pre class="code"> <span style="color: rgb(0,128,0)">// looking up myInt </span> std::map&lt;std::string, AttributeBinder::AttributeDescriptor&gt;::const_iterator i = Foo::binding.attribs.find(<span style="color: rgb(163,21,21)">"myInt"</span>); <span style="color: rgb(0,128,0)">// reading the int </span> <span style="color: rgb(0,0,255)">int</span> intVar = *(<span style="color: rgb(0,0,255)">int</span>*) (ptrdiff_t)&amp;myFoo + i-&gt;second.off; <span style="color: rgb(0,128,0)">// writing the int </span> *((<span style="color: rgb(0,0,255)">int</span>*) (ptrdiff_t)&amp;myFoo + i-&gt;second.off) = 3; </pre><a href="http://11011.net/software/vspaste"><a href="http://11011.net/software/vspaste"></a> <p>&nbsp;</p> <p>This can be prettied up with simple templated member functions, but I leave that as an exercise to the reader.</p>
</article>
</div>
<div id="tags">
programming/code/rtti</tags>

<footer id="footer"> 
	<p>Content by Nick Porcino (c) 1990-2011</p> 
</footer> 
	<!-- /#footer --> 
</div>

</BODY>
</HTML>
