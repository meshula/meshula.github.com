<!DOCTYPE html>
<html id="home" lang="en">
<head>
<meta charset=UTF-8" />
<!-- disable iPhone inital scale --> 
<meta name="viewport" content="width=device-width; initial-scale=1.0" /> <link rel="shortcut icon" href="favicon.ico">  
<!--[if lt IE 9]> 
 <!-- html5.js for IE less than 9 --> 
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
 <!-- css3-mediaqueries.js for IE less than 9 --> 
	<script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
<![endif]--> 
<link rel="stylesheet" href="../css/reset.css" type="text/css" />
<link rel="stylesheet" href="../css/isotype-style.css" type="text/css" media="screen" /> 
<link rel="stylesheet" href="../css/standard.css" type="text/css" />
<link rel="stylesheet" href="../css/buttons.css" type="text/css" /> 
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Aclonica:regular" type="text/css" /> 
<TITLE>
Smallest Possible Attribute System, Part 3
</TITLE></HEAD>
<BODY>
<div id="pagewrap">
<header id="header">
 <hgroup><h1 id="site-logo">Spaces Between</h1></hgroup>
</header>
<DIV id="articleHeader">
<H3 class='entry-date'>2008-07-07 00:48:27</h3>
<H1 class="title">Smallest Possible Attribute System, Part 3</H1>
</DIV>
<div id="content">
<article class="post">
<p></p> <p>Okay, barring suggestions from you, I'm done with SPAS. It does what I wanted it to do, and there's enough substance there for SPAS to be useful as a tutorial. The final result is here: <a href="http://meshula.net/download/AttributeBinder.h">AttributeBinder.h</a>, <a href="http://meshula.net/download/AttributeBinder.cpp">AttributeBinder.cpp</a>, and you'll need the <a href="http://meshula.net/wordpress/?p=183">StringMap</a>.</p> <p>&nbsp;</p> <h3>Our Story To Date</h3> <p>In the <a href="http://meshula.net/wordpress/?p=172">first edition</a>, I introduced a tiny attribute system based around a Binder per class, and a Descriptor per attribute within each bound class. By reader suggestion, I extended it to allow for inheritance, although I didn't wind up supporting multiple inheritance; you can read some of my <a href="http://meshula.net/wordpress/?p=182">research</a> as to why multiple inheritance is not great for performant code here. </p> <p>An <a href="http://meshula.net/wordpress/?p=174">update</a>, changed the typeName in the Descriptor to be a const char* instead of a std::string. This was born from the realization that the binders are all statically initialized any way, so why duplicate the string data? Per reader comments, it turned out to be possible to eliminate more string copies.</p> <p>Then, I introduced a <a href="http://meshula.net/wordpress/?p=177">type mechanism</a> to replace the use of C++ RTTI. </p> <p>Next I introduced Bentley &amp; Sedgewick's <a href="http://meshula.net/wordpress/?p=183">ternary search tree</a> to make type look up fast, and to allow typeId to be cached as an int. This code introduced some thread-unsafety, which could be mitigated by putting a critical section at the spot indicated in the StringMap code, or in the type registration code. My logic for not doing so at the moment is that the classes are all bound at start, before main begins, and as the user won't have been able to launch any threads yet, there's no possibility of a stomp. If you were to add types later in a threaded runtime, a thread safety method would be needed. An alternative to the proposed critical section would be to implement a <a href="http://meshula.net/wordpress/?p=155">lock-free CAS</a> style mechanism to the search tree; generally these are difficult to write, but given some similarities in the tree to a list, it might not be difficult to implement. </p> <p>&nbsp;</p> <h3>Meanwhile, back at the ranch</h3> <p>I had a look at reasonable applications for SPAS, and came up with:</p> <ul> <li>Script variable binding to C++ data <li>Disk serialization <li>Network transmission <li>Editor binding</li></ul> <p>To support all of that, I thought it would be good to show binary reflection as part of the tutorial. Suddenly, the Smallest Possible Attribute System became not the smallest possible. </p> <p>&nbsp;</p> <h3>Feature Creep</h3> <p>I had certain design features I wanted to hit, like</p> <ul> <li>having the reflected data generally immune to changes to the reflected classes. I also wanted to keep the reflected data as small as possible. That meant I needed a type and variable table in the reflected data. <li>reflecting contained objects as well as pointed-to objects. This introduced the need for class factories. <li>no overhead or wrappers on bound variables, reinterpret_cast is the means to get at a variable <li>does not impose vtables <li>minimal programmer interface <li>no templated attribute types - I want to keep the code as light as possible without needing to specialize the code per type <li>support pod (plain old data) <li>does not use built in C++ RTTI mechanisms - disassembly of typeinfo operations revealed a shocking world of string compares <li>text serialization would be an exercise to the reader. I personally don't need it, although the tutorial code includes a trivial version using ostream and stringstream.</li></ul> <p>Current implementation limitations, that exist for no particularly good reason except that I don't currently need them, or that they would obscure the tutorial nature of the code:</p> <ul> <li>No platform swizzles, so data can't be serialized on one machine and deserialized on a machine with different endianness. <li>No cross-compatibility between 32 and 64 bit systems. <li>No automatic padding to ensure aligned reads and writes. <li>No support for arrays of data <li>No support for multiple inherited objects <li>No support for STL containers</li></ul> <p>I refer you to the implementation and surrounding documentation to discover the serialization algorithm.</p> <p>&nbsp;</p> <h3>How about an example?</h3> <p>A minimal set of macros is used to reflect an object. Here's an example of three classes, demonstrating containment, pointers, and inheritance.</p><pre class="code"><span style="color: rgb(0,0,255)">class</span> Bar { <span style="color: rgb(0,0,255)">public</span>: BIND_START; BIND(Bar, yay, <span style="color: rgb(0,0,255)">float</span>); BIND_END; Bar() : yay(33) { } <span style="color: rgb(0,0,255)">float</span> yay; }; BIND_ATTRIBUTES(Bar);</pre><a href="http://11011.net/software/vspaste"></a><pre class="code"><span style="color: rgb(0,0,255)">class</span> Foo { <span style="color: rgb(0,0,255)">public</span>: <span style="color: rgb(0,0,255)">struct</span> FailType { }; BIND_START; BIND(Foo, myInt, <span style="color: rgb(0,0,255)">int</span>); BIND(Foo, myFloat, <span style="color: rgb(0,0,255)">float</span>); BIND(Foo, stuff, <span style="color: rgb(0,0,255)">char</span>*); BIND(Foo, stuff2, std::string); BIND(Foo, yow, <span style="color: rgb(0,0,255)">bool</span>); BIND(Foo, fail, FailType); BIND(Foo, bar, Bar); BIND_END; Foo() : myInt(1), myFloat(2), yow(<span style="color: rgb(0,0,255)">false</span>) { strcpy(stuff, <span style="color: rgb(163,21,21)">"Some text"</span>); stuff2 = <span style="color: rgb(163,21,21)">"More text"</span>; } <span style="color: rgb(0,0,255)">int</span> myInt; <span style="color: rgb(0,0,255)">float</span> myFloat; <span style="color: rgb(0,0,255)">char</span> stuff[32]; <span style="color: rgb(0,0,255)">bool</span> yow; Bar bar; std::string stuff2; FailType fail; }; BIND_ATTRIBUTES(Foo); <span style="color: rgb(0,0,255)">class</span> Baz : <span style="color: rgb(0,0,255)">public</span> Foo { <span style="color: rgb(0,0,255)">public</span>: BIND_START; BIND_BASE(Foo); BIND(Baz, bool1, <span style="color: rgb(0,0,255)">bool</span>); BIND(Baz, int2, <span style="color: rgb(0,0,255)">int</span>); BIND(Baz, float3, <span style="color: rgb(0,0,255)">float</span>); BIND(Baz, nullBarTest, Bar*); BIND(Baz, barTest, Bar*); BIND_END; Baz() : bool1(<span style="color: rgb(0,0,255)">true</span>), int2(2), float3(3), nullBarTest(0) { barTest = <span style="color: rgb(0,0,255)">new</span> Bar(); barTest-&gt;yay = 12.0f; } <span style="color: rgb(0,0,255)">bool</span> bool1; <span style="color: rgb(0,0,255)">int</span> int2; <span style="color: rgb(0,0,255)">float</span> float3; Bar* nullBarTest; Bar* barTest; }; BIND_ATTRIBUTES(Baz);</pre> <p>These macros introduce a static member of type AttributeBinder to every class. AttributeBinder provides a few interesting methods - WriteBinary, ReadBinary, and a StringMap of attribute names to AttributeDescriptors. AttributeDescriptors know how to find the member in the class, how big a member is, and a little descriptive information such as type. In general, one would look up a variable on the AttributeBinder, and then turn the descriptor into a pointer.</p><pre class="code"> Baz myFoo; AttributeBinder::AttributeDescriptor ad; Foo::binding.attribs.find(<span style="color: rgb(163,21,21)">"myInt"</span>, &amp;ad); <span style="color: rgb(0,0,255)">int</span>* intPtr = (<span style="color: rgb(0,0,255)">int</span>*) ad.DataAddr(&amp;myFoo); </pre><a href="http://11011.net/software/vspaste"></a> <p>&nbsp;</p> <h3>An Exercise for the Reader</h3> <p>I've left error handling as a dreaded exercise to the reader, especially since everyone's error handling mechanisms are so different, depending on the application. One could specify an error handling policy or trait on the AttributeBinder, but whatever.</p> <p>The code is heavily documented (it's not self-documenting, I documented it!), and available here:</p> <p><a href="http://meshula.net/download/AttributeBinder.h">AttributeBinder.h</a>, <a href="http://meshula.net/download/AttributeBinder.cpp">AttributeBinder.cpp</a></p> <p>Enjoy! With a bit of thought some of the limitations, cruftiness, and bloat could be eliminated to make this code <em>actually</em> the Smallest Possible Attribute System.</p><pre class="code">&nbsp;</pre><a href="http://11011.net/software/vspaste"></a> <hr> <h3>Research</h3> <p>General searching revealed a number of homebrew type systems, and a variety of sophisticated implementations such as that in <a href="http://www.boost.org/doc/libs/1_35_0/libs/python/doc/index.html">boost python</a>. To show why SPAS has a purpose in the face of so many alternatives, I turn to Game Programming Gems volume 2 where examples and tutorial explanations of all the common mechanisms can be found. I recommend this volume for those of you wanting to do your own research into this topic.</p> <h4>Scott Wakelin, <strong>Dynamic Type Information</strong>, Game Gems 2, pp. 38-45</h4> <p>Similarities:</p> <ul> <li>Type info is a class statically embedded in each reflectable class. <li>Has a pointer to parent class to encode a class hierarchy. <li>No support for multiple inheritance, although it should be possible in Scott's system due to reliance on C++ RTTI. <li>Type equivalence can be determined for the class, or downcasts.</li></ul> <p>Differences:</p> <ul> <li>Scott's system uses C++ RTTI in order to check type equivalence of upcasts. <li>Scott's system uses dynamic_cast, which requires the existence of a vtable. <li>Scott's system uses the &lt;&lt; operator which I avoid because I am not at all pleased with the disassembly I see, nor am I pleased with the appearance of &lt;&lt; execution during profiling <li>Scott's system doesn't handle pointer types</li></ul> <h4>Charles Capelli, <strong>A Property Class for Generic C++ Member Access</strong>, Game Gems 2, pp. 46-50</h4> <p>Charles' system is similar in intent to C# properties. He introduces a property class to wrap each variable, and a property set to iterate over them. SPAS also has a property set which can be iterated. Charles' system is a traditional templated specialization system.</p> <h4>Kasse Staff Jensen, <strong>A Generic Tweaker</strong>, Game Gems 2, pp. 118-126</h4> <p>Kasse's system shares with SPAS the design goal of not imposing overhead on reflected variables, and the goal of having an absolutely minimal API burden. Kasse's system uses a templated class type to identify things, and imposes a vtable to get C++ RTTI.</p> <p>Similarly to SPAS, Kasse's system uses a map to go from the name of a variable to the variable, and it uses reinterpret_cast to get at the real variable.</p>
</article>
</div>
<div id="tags">
programming/code/rtti</tags>

<footer id="footer"> 
	<p>Content by Nick Porcino (c) 1990-2011</p> 
</footer> 
	<!-- /#footer --> 
</div>

</BODY>
</HTML>
