<!DOCTYPE html>
<html id="home" lang="en">
<head>
<meta charset=UTF-8" />
<!-- disable iPhone inital scale --> 
<meta name="viewport" content="width=device-width; initial-scale=1.0" /> <link rel="shortcut icon" href="favicon.ico">  
<!--[if lt IE 9]> 
 <!-- html5.js for IE less than 9 --> 
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
 <!-- css3-mediaqueries.js for IE less than 9 --> 
	<script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
<![endif]--> 
<link rel="stylesheet" href="../css/reset.css" type="text/css" />
<link rel="stylesheet" href="../css/isotype-style.css" type="text/css" media="screen" /> 
<link rel="stylesheet" href="../css/standard.css" type="text/css" />
<link rel="stylesheet" href="../css/buttons.css" type="text/css" /> 
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Aclonica:regular" type="text/css" /> 
<TITLE>
StringMap
</TITLE></HEAD>
<BODY>
<div id="pagewrap">
<header id="header">
 <hgroup><h1 id="site-logo">Spaces Between</h1></hgroup>
</header>
<DIV id="articleHeader">
<H3 class='entry-date'>2008-07-06 20:37:26</h3>
<H1 class="title">StringMap</H1>
</DIV>
<div id="content">
<article class="post">
<p>The smallest possible attribute system needed a fastest possible lookup. Functionally, a std::map&lt;std::string, int&gt; or std::map&lt;const char*, int, Pred&gt; might have done the job. The performance wasn't there however. I did a bit of research and discovered ternary search trees by Bentley and Sedgewick; wrapped them up with a template to turn what was effectively a set into a map, timed it, and provide the result here. Note that real production code would test for error conditions, and deal with them in a fashion appropriate to your application.</p> <p>This code is intended to get you thinking about what kind of container might be appropriate to the job you have at hand, and also to encourage you to not limit yourself to what the library vendor provided you or what dogma might dictate.</p> <h3>Timing</h3> <p>For a timing test, I read in a <a href="http://www.google.com/search?q=dictionary.txt&amp;rls=com.microsoft:en-us:IE-SearchBox&amp;ie=UTF-8&amp;oe=UTF-8&amp;sourceid=ie7&amp;rlz=1I7GGLR">dictionary</a>, added it to a std::map and a StringMap in alphabetical order, shuffled the dictionary and added all the words out of order, then shuffled the dictionary again, and searched for all the words in the map and the StringMap. In general, the results below can be multiplied by two to know how fast StringMap runs in debug, and multiplied by six to ten to know how fast std::map runs in debug. Timings are reported in CPU cycles, and measured under MSVC 2008 with the out of the box STL, optimized build, multi-threaded release libraries, RTTI and exceptions turned on.</p> <p>Update. I have averaged many more samples. I have retested with all combinations of RTTI and exceptions off and on. Contrary to conventional wisdom, I was not able to measure a statistically significant difference between the performance of all four variations. </p> <table cellspacing="0" cellpadding="2" width="400" border="0"> <tbody> <tr> <td valign="top" width="133"><strong>Test</strong></td> <td valign="top" width="133"><strong>std::map</strong></td> <td valign="top" width="133"><strong>StringMap</strong></td></tr> <tr> <td valign="top" width="133">insert, in order</td> <td valign="top" width="133">540M</td> <td valign="top" width="133">55M</td></tr> <tr> <td valign="top" width="133">insert, shuffled</td> <td valign="top" width="133">540M</td> <td valign="top" width="133">85M</td></tr> <tr> <td valign="top" width="133">find all</td> <td valign="top" width="133">260M</td> <td valign="top" width="133">85M</td></tr></tbody></table> <h3> Observations</h3> <p>A further benefit of StringMap is that very few heap allocations are involved. The insert time of std::map could be improved with a custom predicator, and a custom allocator, however the find time can't be improved greatly. One of the big differences between a map of strings and a StringMap is that during find, the std::map needs to do a strcmp for every node of the tree it visits, whereas the StringMap advances a character at a time through the search string as it advances through the nodes. This alone makes a huge difference.</p> <p>The last merit I want to point out is the sheer tiny elegance of Bentley and Sedgewick's code - insert is a mind boggling 50 lines, and find is a mere 22 lines long. (Ignore my clumsy InOrder function, it's not the elegant part!)</p> <p>If you want to use this code as a set, remove the Data from the Tnode, and all references to it - this will bring the code back in line with the original.</p> <p>For more information and formal performance analysis on ternary search trees, I refer you to Bentley &amp; Sedgewick's <a href="http://www.ddj.com/windows/184410528">informative article at Dr. Dobb's</a>, and their <a href="http://www.cs.princeton.edu/~rs/strings/">scholarly research</a>.</p> <h3>Exception Safety</h3> <p>The code as presented here is exception safe. I have replaced the malloc/free in the original posting with new[]/delete[], and added a throw of bad::alloc in the case of filling up all the pools. It is permissible for assignment of data to throw an exception, it is up to the user of the StringMap to catch and respond accordingly - if data cannot be assigned, it is not up to StringMap to do something about it.</p> <p>&nbsp;</p><pre class="code"><span style="color: rgb(0,0,255)">#ifndef</span> STRINGMAP_H <span style="color: rgb(0,0,255)">#define</span> STRINGMAP_H <span style="color: rgb(0,0,255)">#include</span> <span style="color: rgb(163,21,21)">&lt;stdlib.h&gt;</span> <span style="color: rgb(0,128,0)">// for malloc/free </span><span style="color: rgb(0,0,255)">#include</span> <span style="color: rgb(163,21,21)">&lt;vector&gt;</span> <span style="color: rgb(0,128,0)">// for the InOrder function. /* This code is described in "Ternary Search Trees" by Jon Bentley and Robert Sedgewick in the April, 1998, Dr. Dobb's Journal. http://www.ddj.com/windows/184410528 Other algorithms and analysis are available here: http://www.cs.princeton.edu/~rs/strings/ Ternary search trees offer substantial advantages over both binary search trees and digital search tries. We feel that they are superior to hashing in many applications for the following reasons: Efficient and easy to implement No extra overhead for insertion or successful searches Usually substantially faster than hashing for unsuccessful searches Gracefully grow and shrink; hash tables need to be rebuilt after large size changes Support advanced searches, such as partial-match and near-neighbor search. Traversal to report items in sorted order. ------------------------------------------------- I've added the StringMap template wrapper to encapsulate the glboal variables in Bentley &amp; Sedgewick's original code. Otherwise, this implementation is substantially identical. StringMap needs a simple and efficient iterator in order to get rid of the InOrder method I haven't bothered with adding an erase function, or STL compatibility, because my goal is an as-light-as-possible symbol table look up. The extra complexity doesn't help that goal. */ </span><span style="color: rgb(0,0,255)">#ifdef</span> HAVE_EXCEPTIONS <span style="color: rgb(128,128,128)"># define STRINGMAP_ERROR throw std::bad_alloc(); </span><span style="color: rgb(0,0,255)">#else # include</span> <span style="color: rgb(163,21,21)">&lt;assert.h&gt; </span><span style="color: rgb(0,0,255)"># define</span> STRINGMAP_ERROR assert(<span style="color: rgb(0,0,255)">false</span>); <span style="color: rgb(0,0,255)">#endif template</span> &lt;<span style="color: rgb(0,0,255)">class</span> Data&gt; <span style="color: rgb(0,0,255)">class</span> StringMap { <span style="color: rgb(0,0,255)">public</span>: <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">const</span> <span style="color: rgb(0,0,255)">int</span> buffPoolGrowSize = 1000; <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">const</span> <span style="color: rgb(0,0,255)">int</span> maxPools = 1000; <span style="color: rgb(0,0,255)">struct</span> Tnode { <span style="color: rgb(0,0,255)">char</span> splitchar; Data data; Tnode* lokid; Tnode* eqkid; <span style="color: rgb(0,128,0)">// contains middle kid if splitchar != 0, else char* pointer to full string (node is a leaf) </span> Tnode* hikid; }; StringMap() : buf(0), bufn(0), freen(0), size(0), root(0) { memset(freearr, 0, <span style="color: rgb(0,0,255)">sizeof</span>(freearr)); } ~StringMap() { <span style="color: rgb(0,0,255)">for</span> (<span style="color: rgb(0,0,255)">int</span> i = 0; i &lt; freen; i++) <span style="color: rgb(0,0,255)">delete</span>[](freearr[i]); } <span style="color: rgb(0,128,0)">// A major cost of insert functions is calling malloc to create each node. </span> <span style="color: rgb(0,128,0)">// This function uses the ancient C technique of allocating a buffer of nodes and </span> <span style="color: rgb(0,128,0)">// dealing them out as needed. Profiling shows that this eliminates most of the </span> <span style="color: rgb(0,128,0)">// time spent in storage allocation. </span> <span style="color: rgb(0,0,255)">void</span> insert(<span style="color: rgb(0,0,255)">char</span> <span style="color: rgb(0,0,255)">const</span>* s, <span style="color: rgb(0,0,255)">const</span> Data&amp; data) { <span style="color: rgb(0,0,255)">char</span> <span style="color: rgb(0,0,255)">const</span>* instr = s; Tnode* pp; Tnode** p; p = &amp;root; <span style="color: rgb(0,0,255)">while</span> (pp = *p) { <span style="color: rgb(0,128,0)">// optimization: save a difference in a comparison </span> <span style="color: rgb(0,0,255)">int</span> d; <span style="color: rgb(0,0,255)">if</span> ((d = *s - pp-&gt;splitchar) == 0) { <span style="color: rgb(0,0,255)">if</span> (*s++ == 0) <span style="color: rgb(0,0,255)">return</span>; p = &amp;(pp-&gt;eqkid); } <span style="color: rgb(0,0,255)">else</span> <span style="color: rgb(0,0,255)">if</span> (d &lt; 0) p = &amp;(pp-&gt;lokid); <span style="color: rgb(0,0,255)">else </span> p = &amp;(pp-&gt;hikid); } <span style="color: rgb(0,0,255)">for</span> (;;) { <span style="color: rgb(0,128,0)">// *p = (Tptr) malloc(sizeof(Tnode)); reference code; this is what the pools replace </span> <span style="color: rgb(0,0,255)">if</span> (bufn-- == 0) { <span style="color: rgb(0,0,255)">if</span> (freen == maxPools - 1) { STRINGMAP_ERROR } buf = <span style="color: rgb(0,0,255)">new</span> Tnode[buffPoolGrowSize]; freearr[freen++] = buf; bufn = buffPoolGrowSize - 1; } *p = buf++; pp = *p; pp-&gt;splitchar = *s; pp-&gt;lokid = pp-&gt;eqkid = pp-&gt;hikid = 0; <span style="color: rgb(0,0,255)">if</span> (*s++ == 0) { <span style="color: rgb(0,128,0)">// store a pointer to every string in the tree; this data will be used by later search </span> <span style="color: rgb(0,128,0)">// exploit the fact that a node with a null splitchar cannot have an eqkid </span> pp-&gt;eqkid = (Tnode*) instr; pp-&gt;data = data; ++size; <span style="color: rgb(0,128,0)">// count it </span> <span style="color: rgb(0,0,255)">return</span>; } p = &amp;(pp-&gt;eqkid); } } <span style="color: rgb(0,128,0)">// If the search character is less, go to lokid; </span> <span style="color: rgb(0,128,0)">// if it is greater, go to hikid; </span> <span style="color: rgb(0,128,0)">// if it is equal, go to the next character and eqkid. </span> <span style="color: rgb(0,0,255)">bool</span> find(<span style="color: rgb(0,0,255)">char</span> <span style="color: rgb(0,0,255)">const</span>* s, Data* data) <span style="color: rgb(0,0,255)">const </span> { Tnode* p; p = root; <span style="color: rgb(0,0,255)">while</span> (p) { <span style="color: rgb(0,0,255)">if</span> (*s &lt; p-&gt;splitchar) p = p-&gt;lokid; <span style="color: rgb(0,0,255)">else</span> <span style="color: rgb(0,0,255)">if</span> (*s == p-&gt;splitchar) { <span style="color: rgb(0,0,255)">if</span> (*s++ == 0) { *data = p-&gt;data; <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(0,0,255)">true</span>; } p = p-&gt;eqkid; } <span style="color: rgb(0,0,255)">else </span> p = p-&gt;hikid; } <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(0,0,255)">false</span>; } <span style="color: rgb(0,0,255)">void</span> inOrderR(std::vector&lt;std::pair&lt;<span style="color: rgb(0,0,255)">char</span> <span style="color: rgb(0,0,255)">const</span>*, Data*&gt; &gt;&amp; nodes, Tnode* p) <span style="color: rgb(0,0,255)">const </span> { <span style="color: rgb(0,0,255)">if</span> (!p) <span style="color: rgb(0,0,255)">return</span>; inOrderR(nodes, p-&gt;lokid); <span style="color: rgb(0,0,255)">if</span> (p-&gt;splitchar) inOrderR(nodes, p-&gt;eqkid); <span style="color: rgb(0,0,255)">else </span> nodes.push_back(std::pair&lt;<span style="color: rgb(0,0,255)">char</span> <span style="color: rgb(0,0,255)">const</span>*, Data*&gt;((<span style="color: rgb(0,0,255)">char</span> <span style="color: rgb(0,0,255)">const</span>*)p-&gt;eqkid, &amp;p-&gt;data)); inOrderR(nodes, p-&gt;hikid); } <span style="color: rgb(0,0,255)">void</span> inOrder(std::vector&lt;std::pair&lt;<span style="color: rgb(0,0,255)">char</span> <span style="color: rgb(0,0,255)">const</span>*, Data*&gt; &gt;&amp; nodes) <span style="color: rgb(0,0,255)">const </span> { inOrderR(nodes, root); } <span style="color: rgb(0,128,0)">// print all members of the tree in order </span> <span style="color: rgb(0,0,255)">void</span> traverse(Tnode* p) { <span style="color: rgb(0,0,255)">if</span> (!p) <span style="color: rgb(0,0,255)">return</span>; traverse(p-&gt;lokid); <span style="color: rgb(0,0,255)">if</span> (p-&gt;splitchar) traverse(p-&gt;eqkid); <span style="color: rgb(0,0,255)">else </span> printf(<span style="color: rgb(163,21,21)">"%s\n"</span>, (<span style="color: rgb(0,0,255)">char</span> *) p-&gt;eqkid); traverse(p-&gt;hikid); } Tnode* buf; <span style="color: rgb(0,128,0)">// next available Tnode </span> <span style="color: rgb(0,0,255)">int</span> bufn; <span style="color: rgb(0,128,0)">// number of Tnodes available in current pool </span> <span style="color: rgb(0,0,255)">int</span> freen; <span style="color: rgb(0,128,0)">// number of pools to be freed </span> Tnode* freearr[maxPools]; <span style="color: rgb(0,128,0)">// all the allocated pools </span> <span style="color: rgb(0,0,255)">int</span> size; <span style="color: rgb(0,128,0)">// number of nodes </span> Tnode* root; <span style="color: rgb(0,128,0)">// root of the tree </span>}; <span style="color: rgb(0,0,255)">#endif </span></pre><a href="http://11011.net/software/vspaste"></a>
</article>
</div>
<div id="tags">
programming/code/stringmap</tags>

<footer id="footer"> 
	<p>Content by Nick Porcino (c) 1990-2011</p> 
</footer> 
	<!-- /#footer --> 
</div>

</BODY>
</HTML>
